@using Salvation.Core.ViewModel
@inject IJSRuntime JS

@if(Talents.Count == 0)
{
    <MudProgressCircular Color="Color.Default" Indeterminate="true" />
}
else
{
    <div>
        <MudText Typo="Typo.h6" Align="Align.Center" Class="@($"mb-4 {(TotalPointsSpent > PointsTotal ? "mud-error-text" : "")}")">@TotalPointsSpent / @PointsTotal</MudText>
    </div>
    <div class="talent-container">
        <div class="talent-grid mud-theme-dark">
            @foreach (var talent in Talents)
            {
                <a href="https://www.wowhead.com/beta/spell=@(talent.TalentEntries[talent.IsSecondChoiceSelected ? 1 : 0].SpellId)"
                    data-wowhead="def=@(talent.TalentEntries[talent.IsSecondChoiceSelected ? 1 : 0].DefinitionId)&rank=@(talent.PointsSpent == 2 ? 2 : 1)" 
                    data-wh-rename-link="false"
                    data-no-touch-lightbox="true"
                    class="talent talent-col-@(talent.TreeColumn) talent-row-@(talent.TreeRow)"
                    @onclick="e => OnTalentClick(e, talent)"
                    @onclick:preventDefault="true"
                    @oncontextmenu="e => OnTalentClick(e, talent)"
                    @oncontextmenu:preventDefault="true" 
                    data-ready="@(talent.PointsSpent == talent.MaxRanks || talent.IsFreeNode ? 0 : 1)"
                    data-node-type="@talent.Type"
                    data-spell-passive="@(talent.Type != NodeTypeChoice && talent.TalentEntries[0].Type == NodeSpellTypePassive ? 1 : 0)"
                    data-node-unlocked="@(talent.IsUnlocked ? 1 : 0)">
                    <div class="talent-contents"data-spell-passive="@(talent.Type != NodeTypeChoice && talent.TalentEntries[0].Type == NodeSpellTypePassive ? 1 : 0)">
                            @if(talent.Type == NodeTypeChoice)
                            {
                                <div class="talent-image-holder">
                                    <div class="talent-image talent-image-choice-left" style="@GetImageStyle(talent.TalentEntries[0].Icon)"
                                        data-ready="@(talent.PointsSpent == talent.MaxRanks || talent.IsFreeNode ? 0 : 1)"
                                        data-choice-selected="@(talent.IsSecondChoiceSelected ? "0" : "1")" >

                                    </div>
                                    <div class="talent-image talent-image-choice-right" style="@GetImageStyle(talent.TalentEntries[1].Icon)"
                                         data-ready="@(talent.PointsSpent == talent.MaxRanks || talent.IsFreeNode ? 0 : 1)" 
                                         data-choice-selected="@(talent.IsSecondChoiceSelected ? "1" : "0")">

                                    </div>
                                </div>
                            }
                            else
                            {
                                <div class="talent-image-holder">
                                    <div class="talent-image" style="@GetImageStyle(talent.TalentEntries[0].Icon)"></div>
                                </div>
                            }
                    </div>
                </a>
                @if (!talent.IsFreeNode)
                {
                    <div class="talent-points-spent talent-col-@(talent.TreeColumn) talent-row-@(talent.TreeRow)">
                        @talent.PointsSpent/@talent.MaxRanks
                    </div>
                }
            }
        </div>
    </div>
}

@code {
    //private static string NodeTypeSingle = "single";
    //private static string NodeTypeTiered = "tiered"; // No idea what this is.
    private static string NodeTypeChoice = "choice"; // Implement something for choice node later
    private static string NodeSpellTypePassive = "passive"; // Passive talents
    private static string UnknownIconName = "inv_misc_questionmark.jpg";
    private int TotalPointsSpent = 0;

    [Parameter]
    public int PointsTotal { get; set; } = 0;

    [Parameter]
    public List<Talent> Talents { get; set; } = new List<Talent>();

    [Parameter]
    public Dictionary<int, int> SelectedTalents { get; set; } = new Dictionary<int, int>();

    public string GetImageStyle(string talentIcon)
    {
        return $"background-image: url('static-data/icons/{talentIcon}.jpg'), url('static-data/icons/{UnknownIconName}');";
    }

    protected override void OnInitialized()
    {
        InitialiseTalents();  
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JS.InvokeVoidAsync("updateWowheadTooltips");

        if(firstRender)
        {
            // Configure all of the talent path lines here?
        }
    }

    private void InitialiseTalents()
    {
        // Update with any supplied selected talents
        foreach (var kvp in SelectedTalents)
        {
            // Check if the talent exists in the talent tree
            var talent = Talents.Where(t => t.TalentEntries.Where(te => te.SpellId == kvp.Key).Count() > 0).FirstOrDefault();

            if (talent != null)
            {
                // If it does, first update the points spent
                var talentEntry = talent.TalentEntries.Where(te => te.SpellId == kvp.Key).FirstOrDefault();

                talent.PointsSpent = kvp.Value;
                talent.IsSecondChoiceSelected = talent.TalentEntries[0] != talentEntry;
            }
        }

        foreach (var talent in Talents)
        {
            if (talent.IsFreeNode)
            {
                talent.PointsSpent = 1;
                UpdateSelectedTalent(talent);
            }
        }

        UpdateUnlockedTalents();
    }

    public void OnTalentClick(MouseEventArgs eventArgs, Talent talent)
    {
        switch(eventArgs.Button)
        {
            case 0:
                TalentLeftClick(eventArgs, talent);
                break;
            case 2:
                TalentRightClick(eventArgs, talent);
                break;
            default:
                break;
        }
    }

    private void TalentLeftClick(MouseEventArgs eventArgs, Talent talent)
    {
        TrySpendTalentPoint(talent);
    }

    private void TalentRightClick(MouseEventArgs eventArgs, Talent talent)
    {
        TryRefundTalentPoint(talent);
    }

    public void TrySpendTalentPoint(Talent talent, bool? selectFirstChoiceOption = null)
    {
        if (!talent.IsFreeNode && talent.PointsSpent < talent.MaxRanks)
        {
            // If there are points to spend, spend them
            talent.PointsSpent++;
            TotalPointsSpent++;
        }
        else if (talent.Type == NodeTypeChoice && talent.PointsSpent > 0)
        {
            talent.IsSecondChoiceSelected = !talent.IsSecondChoiceSelected;
        }

        if (selectFirstChoiceOption.HasValue)
            talent.IsSecondChoiceSelected = !selectFirstChoiceOption.Value;

        UpdateSelectedTalent(talent);

        UpdateUnlockedTalents();
    }

    public void TryRefundTalentPoint(Talent talent)
    {
        // If there are points spent, remove one
        if (talent.PointsSpent > 0 && !talent.IsFreeNode)
        {
            talent.PointsSpent--;
            TotalPointsSpent--;
        }

        UpdateSelectedTalent(talent);

        UpdateUnlockedTalents();
    }

    public void ResetTalentTree()
    {
        foreach(var talent in Talents)
        {
            talent.PointsSpent = 0;
            talent.IsSecondChoiceSelected = false;
        }

        TotalPointsSpent = 0;

        UpdateUnlockedTalents();

        foreach (var talent in Talents)
        {
            UpdateSelectedTalent(talent);
        }
    }

    // Update the SelectedTalents each time a talent changes
    private void UpdateSelectedTalent(Talent talent)
    {
        var spellId = !talent.IsSecondChoiceSelected ? talent.TalentEntries[0].SpellId : talent.TalentEntries[1].SpellId;

        if (!SelectedTalents.ContainsKey(spellId))
            SelectedTalents.Add(spellId, 0);

        SelectedTalents[spellId] = talent.PointsSpent;

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    private void UpdateUnlockedTalents()
    {
        foreach (var talent in Talents)
        {
            var talentIsUnlocked = false;

            // A node is active if:

            // 1. It's a free node
            if (talent.IsFreeNode)
                talentIsUnlocked = true;

            // 2. It's a valid entry node
            if (talent.EntryNode)
            {
                talentIsUnlocked = true;
            }

            // 3. One of its parent nodes is maxed out
            foreach (var parent in Talents.Where(t => t.NextNodes.Contains(talent.Id)))
            {
                if (parent.PointsSpent == parent.MaxRanks)
                    talentIsUnlocked = true;
            }

            // Finally, it can't be unlocked if it doesn't meet required total points
            if (TotalPointsSpent < (talent.RequiredPoints ?? 0))
                talentIsUnlocked = false;

            // It is unlocked though, if you have any points in it
            if (talent.PointsSpent > 0)
                talentIsUnlocked = true;

            talent.IsUnlocked = talentIsUnlocked;
        }
    }
}
